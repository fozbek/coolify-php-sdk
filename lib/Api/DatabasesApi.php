<?php
/**
 * DatabasesApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Coolify
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DatabasesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DatabasesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createDatabaseClickhouse' => [
            'application/json',
        ],
        'createDatabaseDragonfly' => [
            'application/json',
        ],
        'createDatabaseKeydb' => [
            'application/json',
        ],
        'createDatabaseMariadb' => [
            'application/json',
        ],
        'createDatabaseMongodb' => [
            'application/json',
        ],
        'createDatabaseMysql' => [
            'application/json',
        ],
        'createDatabasePostgresql' => [
            'application/json',
        ],
        'createDatabaseRedis' => [
            'application/json',
        ],
        'deleteDatabaseByUuid' => [
            'application/json',
        ],
        'getDatabaseByUuid' => [
            'application/json',
        ],
        'listDatabases' => [
            'application/json',
        ],
        'restartDatabaseByUuid' => [
            'application/json',
        ],
        'startDatabaseByUuid' => [
            'application/json',
        ],
        'stopDatabaseByUuid' => [
            'application/json',
        ],
        'updateDatabaseByUuid' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createDatabaseClickhouse
     *
     * Create (Clickhouse)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseClickhouseRequest $create_database_clickhouse_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseClickhouse'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createDatabaseClickhouse($create_database_clickhouse_request, string $contentType = self::contentTypes['createDatabaseClickhouse'][0])
    {
        $this->createDatabaseClickhouseWithHttpInfo($create_database_clickhouse_request, $contentType);
    }

    /**
     * Operation createDatabaseClickhouseWithHttpInfo
     *
     * Create (Clickhouse)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseClickhouseRequest $create_database_clickhouse_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseClickhouse'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDatabaseClickhouseWithHttpInfo($create_database_clickhouse_request, string $contentType = self::contentTypes['createDatabaseClickhouse'][0])
    {
        $request = $this->createDatabaseClickhouseRequest($create_database_clickhouse_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDatabaseClickhouseAsync
     *
     * Create (Clickhouse)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseClickhouseRequest $create_database_clickhouse_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseClickhouse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseClickhouseAsync($create_database_clickhouse_request, string $contentType = self::contentTypes['createDatabaseClickhouse'][0])
    {
        return $this->createDatabaseClickhouseAsyncWithHttpInfo($create_database_clickhouse_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDatabaseClickhouseAsyncWithHttpInfo
     *
     * Create (Clickhouse)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseClickhouseRequest $create_database_clickhouse_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseClickhouse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseClickhouseAsyncWithHttpInfo($create_database_clickhouse_request, string $contentType = self::contentTypes['createDatabaseClickhouse'][0])
    {
        $returnType = '';
        $request = $this->createDatabaseClickhouseRequest($create_database_clickhouse_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDatabaseClickhouse'
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseClickhouseRequest $create_database_clickhouse_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseClickhouse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDatabaseClickhouseRequest($create_database_clickhouse_request, string $contentType = self::contentTypes['createDatabaseClickhouse'][0])
    {

        // verify the required parameter 'create_database_clickhouse_request' is set
        if ($create_database_clickhouse_request === null || (is_array($create_database_clickhouse_request) && count($create_database_clickhouse_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_database_clickhouse_request when calling createDatabaseClickhouse'
            );
        }


        $resourcePath = '/databases/clickhouse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_database_clickhouse_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_database_clickhouse_request));
            } else {
                $httpBody = $create_database_clickhouse_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDatabaseDragonfly
     *
     * Create (DragonFly)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseDragonflyRequest $create_database_dragonfly_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseDragonfly'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createDatabaseDragonfly($create_database_dragonfly_request, string $contentType = self::contentTypes['createDatabaseDragonfly'][0])
    {
        $this->createDatabaseDragonflyWithHttpInfo($create_database_dragonfly_request, $contentType);
    }

    /**
     * Operation createDatabaseDragonflyWithHttpInfo
     *
     * Create (DragonFly)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseDragonflyRequest $create_database_dragonfly_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseDragonfly'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDatabaseDragonflyWithHttpInfo($create_database_dragonfly_request, string $contentType = self::contentTypes['createDatabaseDragonfly'][0])
    {
        $request = $this->createDatabaseDragonflyRequest($create_database_dragonfly_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDatabaseDragonflyAsync
     *
     * Create (DragonFly)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseDragonflyRequest $create_database_dragonfly_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseDragonfly'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseDragonflyAsync($create_database_dragonfly_request, string $contentType = self::contentTypes['createDatabaseDragonfly'][0])
    {
        return $this->createDatabaseDragonflyAsyncWithHttpInfo($create_database_dragonfly_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDatabaseDragonflyAsyncWithHttpInfo
     *
     * Create (DragonFly)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseDragonflyRequest $create_database_dragonfly_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseDragonfly'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseDragonflyAsyncWithHttpInfo($create_database_dragonfly_request, string $contentType = self::contentTypes['createDatabaseDragonfly'][0])
    {
        $returnType = '';
        $request = $this->createDatabaseDragonflyRequest($create_database_dragonfly_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDatabaseDragonfly'
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseDragonflyRequest $create_database_dragonfly_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseDragonfly'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDatabaseDragonflyRequest($create_database_dragonfly_request, string $contentType = self::contentTypes['createDatabaseDragonfly'][0])
    {

        // verify the required parameter 'create_database_dragonfly_request' is set
        if ($create_database_dragonfly_request === null || (is_array($create_database_dragonfly_request) && count($create_database_dragonfly_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_database_dragonfly_request when calling createDatabaseDragonfly'
            );
        }


        $resourcePath = '/databases/dragonfly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_database_dragonfly_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_database_dragonfly_request));
            } else {
                $httpBody = $create_database_dragonfly_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDatabaseKeydb
     *
     * Create (KeyDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseKeydbRequest $create_database_keydb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseKeydb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createDatabaseKeydb($create_database_keydb_request, string $contentType = self::contentTypes['createDatabaseKeydb'][0])
    {
        $this->createDatabaseKeydbWithHttpInfo($create_database_keydb_request, $contentType);
    }

    /**
     * Operation createDatabaseKeydbWithHttpInfo
     *
     * Create (KeyDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseKeydbRequest $create_database_keydb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseKeydb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDatabaseKeydbWithHttpInfo($create_database_keydb_request, string $contentType = self::contentTypes['createDatabaseKeydb'][0])
    {
        $request = $this->createDatabaseKeydbRequest($create_database_keydb_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDatabaseKeydbAsync
     *
     * Create (KeyDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseKeydbRequest $create_database_keydb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseKeydb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseKeydbAsync($create_database_keydb_request, string $contentType = self::contentTypes['createDatabaseKeydb'][0])
    {
        return $this->createDatabaseKeydbAsyncWithHttpInfo($create_database_keydb_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDatabaseKeydbAsyncWithHttpInfo
     *
     * Create (KeyDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseKeydbRequest $create_database_keydb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseKeydb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseKeydbAsyncWithHttpInfo($create_database_keydb_request, string $contentType = self::contentTypes['createDatabaseKeydb'][0])
    {
        $returnType = '';
        $request = $this->createDatabaseKeydbRequest($create_database_keydb_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDatabaseKeydb'
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseKeydbRequest $create_database_keydb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseKeydb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDatabaseKeydbRequest($create_database_keydb_request, string $contentType = self::contentTypes['createDatabaseKeydb'][0])
    {

        // verify the required parameter 'create_database_keydb_request' is set
        if ($create_database_keydb_request === null || (is_array($create_database_keydb_request) && count($create_database_keydb_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_database_keydb_request when calling createDatabaseKeydb'
            );
        }


        $resourcePath = '/databases/keydb';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_database_keydb_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_database_keydb_request));
            } else {
                $httpBody = $create_database_keydb_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDatabaseMariadb
     *
     * Create (MariaDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMariadbRequest $create_database_mariadb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMariadb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createDatabaseMariadb($create_database_mariadb_request, string $contentType = self::contentTypes['createDatabaseMariadb'][0])
    {
        $this->createDatabaseMariadbWithHttpInfo($create_database_mariadb_request, $contentType);
    }

    /**
     * Operation createDatabaseMariadbWithHttpInfo
     *
     * Create (MariaDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMariadbRequest $create_database_mariadb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMariadb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDatabaseMariadbWithHttpInfo($create_database_mariadb_request, string $contentType = self::contentTypes['createDatabaseMariadb'][0])
    {
        $request = $this->createDatabaseMariadbRequest($create_database_mariadb_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDatabaseMariadbAsync
     *
     * Create (MariaDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMariadbRequest $create_database_mariadb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMariadb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseMariadbAsync($create_database_mariadb_request, string $contentType = self::contentTypes['createDatabaseMariadb'][0])
    {
        return $this->createDatabaseMariadbAsyncWithHttpInfo($create_database_mariadb_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDatabaseMariadbAsyncWithHttpInfo
     *
     * Create (MariaDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMariadbRequest $create_database_mariadb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMariadb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseMariadbAsyncWithHttpInfo($create_database_mariadb_request, string $contentType = self::contentTypes['createDatabaseMariadb'][0])
    {
        $returnType = '';
        $request = $this->createDatabaseMariadbRequest($create_database_mariadb_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDatabaseMariadb'
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMariadbRequest $create_database_mariadb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMariadb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDatabaseMariadbRequest($create_database_mariadb_request, string $contentType = self::contentTypes['createDatabaseMariadb'][0])
    {

        // verify the required parameter 'create_database_mariadb_request' is set
        if ($create_database_mariadb_request === null || (is_array($create_database_mariadb_request) && count($create_database_mariadb_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_database_mariadb_request when calling createDatabaseMariadb'
            );
        }


        $resourcePath = '/databases/mariadb';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_database_mariadb_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_database_mariadb_request));
            } else {
                $httpBody = $create_database_mariadb_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDatabaseMongodb
     *
     * Create (MongoDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMongodbRequest $create_database_mongodb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMongodb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createDatabaseMongodb($create_database_mongodb_request, string $contentType = self::contentTypes['createDatabaseMongodb'][0])
    {
        $this->createDatabaseMongodbWithHttpInfo($create_database_mongodb_request, $contentType);
    }

    /**
     * Operation createDatabaseMongodbWithHttpInfo
     *
     * Create (MongoDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMongodbRequest $create_database_mongodb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMongodb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDatabaseMongodbWithHttpInfo($create_database_mongodb_request, string $contentType = self::contentTypes['createDatabaseMongodb'][0])
    {
        $request = $this->createDatabaseMongodbRequest($create_database_mongodb_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDatabaseMongodbAsync
     *
     * Create (MongoDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMongodbRequest $create_database_mongodb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMongodb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseMongodbAsync($create_database_mongodb_request, string $contentType = self::contentTypes['createDatabaseMongodb'][0])
    {
        return $this->createDatabaseMongodbAsyncWithHttpInfo($create_database_mongodb_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDatabaseMongodbAsyncWithHttpInfo
     *
     * Create (MongoDB)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMongodbRequest $create_database_mongodb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMongodb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseMongodbAsyncWithHttpInfo($create_database_mongodb_request, string $contentType = self::contentTypes['createDatabaseMongodb'][0])
    {
        $returnType = '';
        $request = $this->createDatabaseMongodbRequest($create_database_mongodb_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDatabaseMongodb'
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMongodbRequest $create_database_mongodb_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMongodb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDatabaseMongodbRequest($create_database_mongodb_request, string $contentType = self::contentTypes['createDatabaseMongodb'][0])
    {

        // verify the required parameter 'create_database_mongodb_request' is set
        if ($create_database_mongodb_request === null || (is_array($create_database_mongodb_request) && count($create_database_mongodb_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_database_mongodb_request when calling createDatabaseMongodb'
            );
        }


        $resourcePath = '/databases/mongodb';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_database_mongodb_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_database_mongodb_request));
            } else {
                $httpBody = $create_database_mongodb_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDatabaseMysql
     *
     * Create (MySQL)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMysqlRequest $create_database_mysql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMysql'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createDatabaseMysql($create_database_mysql_request, string $contentType = self::contentTypes['createDatabaseMysql'][0])
    {
        $this->createDatabaseMysqlWithHttpInfo($create_database_mysql_request, $contentType);
    }

    /**
     * Operation createDatabaseMysqlWithHttpInfo
     *
     * Create (MySQL)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMysqlRequest $create_database_mysql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMysql'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDatabaseMysqlWithHttpInfo($create_database_mysql_request, string $contentType = self::contentTypes['createDatabaseMysql'][0])
    {
        $request = $this->createDatabaseMysqlRequest($create_database_mysql_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDatabaseMysqlAsync
     *
     * Create (MySQL)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMysqlRequest $create_database_mysql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMysql'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseMysqlAsync($create_database_mysql_request, string $contentType = self::contentTypes['createDatabaseMysql'][0])
    {
        return $this->createDatabaseMysqlAsyncWithHttpInfo($create_database_mysql_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDatabaseMysqlAsyncWithHttpInfo
     *
     * Create (MySQL)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMysqlRequest $create_database_mysql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMysql'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseMysqlAsyncWithHttpInfo($create_database_mysql_request, string $contentType = self::contentTypes['createDatabaseMysql'][0])
    {
        $returnType = '';
        $request = $this->createDatabaseMysqlRequest($create_database_mysql_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDatabaseMysql'
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseMysqlRequest $create_database_mysql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseMysql'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDatabaseMysqlRequest($create_database_mysql_request, string $contentType = self::contentTypes['createDatabaseMysql'][0])
    {

        // verify the required parameter 'create_database_mysql_request' is set
        if ($create_database_mysql_request === null || (is_array($create_database_mysql_request) && count($create_database_mysql_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_database_mysql_request when calling createDatabaseMysql'
            );
        }


        $resourcePath = '/databases/mysql';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_database_mysql_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_database_mysql_request));
            } else {
                $httpBody = $create_database_mysql_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDatabasePostgresql
     *
     * Create (PostgreSQL)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabasePostgresqlRequest $create_database_postgresql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabasePostgresql'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createDatabasePostgresql($create_database_postgresql_request, string $contentType = self::contentTypes['createDatabasePostgresql'][0])
    {
        $this->createDatabasePostgresqlWithHttpInfo($create_database_postgresql_request, $contentType);
    }

    /**
     * Operation createDatabasePostgresqlWithHttpInfo
     *
     * Create (PostgreSQL)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabasePostgresqlRequest $create_database_postgresql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabasePostgresql'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDatabasePostgresqlWithHttpInfo($create_database_postgresql_request, string $contentType = self::contentTypes['createDatabasePostgresql'][0])
    {
        $request = $this->createDatabasePostgresqlRequest($create_database_postgresql_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDatabasePostgresqlAsync
     *
     * Create (PostgreSQL)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabasePostgresqlRequest $create_database_postgresql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabasePostgresql'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabasePostgresqlAsync($create_database_postgresql_request, string $contentType = self::contentTypes['createDatabasePostgresql'][0])
    {
        return $this->createDatabasePostgresqlAsyncWithHttpInfo($create_database_postgresql_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDatabasePostgresqlAsyncWithHttpInfo
     *
     * Create (PostgreSQL)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabasePostgresqlRequest $create_database_postgresql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabasePostgresql'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabasePostgresqlAsyncWithHttpInfo($create_database_postgresql_request, string $contentType = self::contentTypes['createDatabasePostgresql'][0])
    {
        $returnType = '';
        $request = $this->createDatabasePostgresqlRequest($create_database_postgresql_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDatabasePostgresql'
     *
     * @param  \OpenAPI\Client\Model\CreateDatabasePostgresqlRequest $create_database_postgresql_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabasePostgresql'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDatabasePostgresqlRequest($create_database_postgresql_request, string $contentType = self::contentTypes['createDatabasePostgresql'][0])
    {

        // verify the required parameter 'create_database_postgresql_request' is set
        if ($create_database_postgresql_request === null || (is_array($create_database_postgresql_request) && count($create_database_postgresql_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_database_postgresql_request when calling createDatabasePostgresql'
            );
        }


        $resourcePath = '/databases/postgresql';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_database_postgresql_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_database_postgresql_request));
            } else {
                $httpBody = $create_database_postgresql_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDatabaseRedis
     *
     * Create (Redis)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseRedisRequest $create_database_redis_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseRedis'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createDatabaseRedis($create_database_redis_request, string $contentType = self::contentTypes['createDatabaseRedis'][0])
    {
        $this->createDatabaseRedisWithHttpInfo($create_database_redis_request, $contentType);
    }

    /**
     * Operation createDatabaseRedisWithHttpInfo
     *
     * Create (Redis)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseRedisRequest $create_database_redis_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseRedis'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDatabaseRedisWithHttpInfo($create_database_redis_request, string $contentType = self::contentTypes['createDatabaseRedis'][0])
    {
        $request = $this->createDatabaseRedisRequest($create_database_redis_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDatabaseRedisAsync
     *
     * Create (Redis)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseRedisRequest $create_database_redis_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseRedis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseRedisAsync($create_database_redis_request, string $contentType = self::contentTypes['createDatabaseRedis'][0])
    {
        return $this->createDatabaseRedisAsyncWithHttpInfo($create_database_redis_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDatabaseRedisAsyncWithHttpInfo
     *
     * Create (Redis)
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseRedisRequest $create_database_redis_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseRedis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDatabaseRedisAsyncWithHttpInfo($create_database_redis_request, string $contentType = self::contentTypes['createDatabaseRedis'][0])
    {
        $returnType = '';
        $request = $this->createDatabaseRedisRequest($create_database_redis_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDatabaseRedis'
     *
     * @param  \OpenAPI\Client\Model\CreateDatabaseRedisRequest $create_database_redis_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDatabaseRedis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDatabaseRedisRequest($create_database_redis_request, string $contentType = self::contentTypes['createDatabaseRedis'][0])
    {

        // verify the required parameter 'create_database_redis_request' is set
        if ($create_database_redis_request === null || (is_array($create_database_redis_request) && count($create_database_redis_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_database_redis_request when calling createDatabaseRedis'
            );
        }


        $resourcePath = '/databases/redis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_database_redis_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_database_redis_request));
            } else {
                $httpBody = $create_database_redis_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDatabaseByUuid
     *
     * Delete
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  bool|null $delete_configurations Delete configurations. (optional, default to true)
     * @param  bool|null $delete_volumes Delete volumes. (optional, default to true)
     * @param  bool|null $docker_cleanup Run docker cleanup. (optional, default to true)
     * @param  bool|null $delete_connected_networks Delete connected networks. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\DeleteDatabaseByUuid200Response|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2
     */
    public function deleteDatabaseByUuid($uuid, $delete_configurations = true, $delete_volumes = true, $docker_cleanup = true, $delete_connected_networks = true, string $contentType = self::contentTypes['deleteDatabaseByUuid'][0])
    {
        list($response) = $this->deleteDatabaseByUuidWithHttpInfo($uuid, $delete_configurations, $delete_volumes, $docker_cleanup, $delete_connected_networks, $contentType);
        return $response;
    }

    /**
     * Operation deleteDatabaseByUuidWithHttpInfo
     *
     * Delete
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  bool|null $delete_configurations Delete configurations. (optional, default to true)
     * @param  bool|null $delete_volumes Delete volumes. (optional, default to true)
     * @param  bool|null $docker_cleanup Run docker cleanup. (optional, default to true)
     * @param  bool|null $delete_connected_networks Delete connected networks. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\DeleteDatabaseByUuid200Response|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDatabaseByUuidWithHttpInfo($uuid, $delete_configurations = true, $delete_volumes = true, $docker_cleanup = true, $delete_connected_networks = true, string $contentType = self::contentTypes['deleteDatabaseByUuid'][0])
    {
        $request = $this->deleteDatabaseByUuidRequest($uuid, $delete_configurations, $delete_volumes, $docker_cleanup, $delete_connected_networks, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\DeleteDatabaseByUuid200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject1',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject2',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\DeleteDatabaseByUuid200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DeleteDatabaseByUuid200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteDatabaseByUuidAsync
     *
     * Delete
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  bool|null $delete_configurations Delete configurations. (optional, default to true)
     * @param  bool|null $delete_volumes Delete volumes. (optional, default to true)
     * @param  bool|null $docker_cleanup Run docker cleanup. (optional, default to true)
     * @param  bool|null $delete_connected_networks Delete connected networks. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDatabaseByUuidAsync($uuid, $delete_configurations = true, $delete_volumes = true, $docker_cleanup = true, $delete_connected_networks = true, string $contentType = self::contentTypes['deleteDatabaseByUuid'][0])
    {
        return $this->deleteDatabaseByUuidAsyncWithHttpInfo($uuid, $delete_configurations, $delete_volumes, $docker_cleanup, $delete_connected_networks, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDatabaseByUuidAsyncWithHttpInfo
     *
     * Delete
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  bool|null $delete_configurations Delete configurations. (optional, default to true)
     * @param  bool|null $delete_volumes Delete volumes. (optional, default to true)
     * @param  bool|null $docker_cleanup Run docker cleanup. (optional, default to true)
     * @param  bool|null $delete_connected_networks Delete connected networks. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDatabaseByUuidAsyncWithHttpInfo($uuid, $delete_configurations = true, $delete_volumes = true, $docker_cleanup = true, $delete_connected_networks = true, string $contentType = self::contentTypes['deleteDatabaseByUuid'][0])
    {
        $returnType = '\OpenAPI\Client\Model\DeleteDatabaseByUuid200Response';
        $request = $this->deleteDatabaseByUuidRequest($uuid, $delete_configurations, $delete_volumes, $docker_cleanup, $delete_connected_networks, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDatabaseByUuid'
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  bool|null $delete_configurations Delete configurations. (optional, default to true)
     * @param  bool|null $delete_volumes Delete volumes. (optional, default to true)
     * @param  bool|null $docker_cleanup Run docker cleanup. (optional, default to true)
     * @param  bool|null $delete_connected_networks Delete connected networks. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDatabaseByUuidRequest($uuid, $delete_configurations = true, $delete_volumes = true, $docker_cleanup = true, $delete_connected_networks = true, string $contentType = self::contentTypes['deleteDatabaseByUuid'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling deleteDatabaseByUuid'
            );
        }






        $resourcePath = '/databases/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete_configurations,
            'delete_configurations', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete_volumes,
            'delete_volumes', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $docker_cleanup,
            'docker_cleanup', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete_connected_networks,
            'delete_connected_networks', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDatabaseByUuid
     *
     * Get
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2
     */
    public function getDatabaseByUuid($uuid, string $contentType = self::contentTypes['getDatabaseByUuid'][0])
    {
        list($response) = $this->getDatabaseByUuidWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation getDatabaseByUuidWithHttpInfo
     *
     * Get
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDatabaseByUuidWithHttpInfo($uuid, string $contentType = self::contentTypes['getDatabaseByUuid'][0])
    {
        $request = $this->getDatabaseByUuidRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject1',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject2',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDatabaseByUuidAsync
     *
     * Get
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDatabaseByUuidAsync($uuid, string $contentType = self::contentTypes['getDatabaseByUuid'][0])
    {
        return $this->getDatabaseByUuidAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDatabaseByUuidAsyncWithHttpInfo
     *
     * Get
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDatabaseByUuidAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['getDatabaseByUuid'][0])
    {
        $returnType = 'string';
        $request = $this->getDatabaseByUuidRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDatabaseByUuid'
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDatabaseByUuidRequest($uuid, string $contentType = self::contentTypes['getDatabaseByUuid'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling getDatabaseByUuid'
            );
        }


        $resourcePath = '/databases/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDatabases
     *
     * List
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDatabases'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject
     */
    public function listDatabases(string $contentType = self::contentTypes['listDatabases'][0])
    {
        list($response) = $this->listDatabasesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listDatabasesWithHttpInfo
     *
     * List
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDatabases'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDatabasesWithHttpInfo(string $contentType = self::contentTypes['listDatabases'][0])
    {
        $request = $this->listDatabasesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject1',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listDatabasesAsync
     *
     * List
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDatabases'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDatabasesAsync(string $contentType = self::contentTypes['listDatabases'][0])
    {
        return $this->listDatabasesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDatabasesAsyncWithHttpInfo
     *
     * List
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDatabases'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDatabasesAsyncWithHttpInfo(string $contentType = self::contentTypes['listDatabases'][0])
    {
        $returnType = 'string';
        $request = $this->listDatabasesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDatabases'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDatabases'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDatabasesRequest(string $contentType = self::contentTypes['listDatabases'][0])
    {


        $resourcePath = '/databases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restartDatabaseByUuid
     *
     * Restart
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restartDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RestartDatabaseByUuid200Response|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2
     */
    public function restartDatabaseByUuid($uuid, string $contentType = self::contentTypes['restartDatabaseByUuid'][0])
    {
        list($response) = $this->restartDatabaseByUuidWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation restartDatabaseByUuidWithHttpInfo
     *
     * Restart
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restartDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RestartDatabaseByUuid200Response|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2, HTTP status code, HTTP response headers (array of strings)
     */
    public function restartDatabaseByUuidWithHttpInfo($uuid, string $contentType = self::contentTypes['restartDatabaseByUuid'][0])
    {
        $request = $this->restartDatabaseByUuidRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RestartDatabaseByUuid200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject1',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject2',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\RestartDatabaseByUuid200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RestartDatabaseByUuid200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation restartDatabaseByUuidAsync
     *
     * Restart
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restartDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restartDatabaseByUuidAsync($uuid, string $contentType = self::contentTypes['restartDatabaseByUuid'][0])
    {
        return $this->restartDatabaseByUuidAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restartDatabaseByUuidAsyncWithHttpInfo
     *
     * Restart
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restartDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restartDatabaseByUuidAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['restartDatabaseByUuid'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RestartDatabaseByUuid200Response';
        $request = $this->restartDatabaseByUuidRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restartDatabaseByUuid'
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restartDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restartDatabaseByUuidRequest($uuid, string $contentType = self::contentTypes['restartDatabaseByUuid'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling restartDatabaseByUuid'
            );
        }


        $resourcePath = '/databases/{uuid}/restart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startDatabaseByUuid
     *
     * Start
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StartDatabaseByUuid200Response|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2
     */
    public function startDatabaseByUuid($uuid, string $contentType = self::contentTypes['startDatabaseByUuid'][0])
    {
        list($response) = $this->startDatabaseByUuidWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation startDatabaseByUuidWithHttpInfo
     *
     * Start
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StartDatabaseByUuid200Response|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2, HTTP status code, HTTP response headers (array of strings)
     */
    public function startDatabaseByUuidWithHttpInfo($uuid, string $contentType = self::contentTypes['startDatabaseByUuid'][0])
    {
        $request = $this->startDatabaseByUuidRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StartDatabaseByUuid200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject1',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject2',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StartDatabaseByUuid200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StartDatabaseByUuid200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation startDatabaseByUuidAsync
     *
     * Start
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startDatabaseByUuidAsync($uuid, string $contentType = self::contentTypes['startDatabaseByUuid'][0])
    {
        return $this->startDatabaseByUuidAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startDatabaseByUuidAsyncWithHttpInfo
     *
     * Start
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startDatabaseByUuidAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['startDatabaseByUuid'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StartDatabaseByUuid200Response';
        $request = $this->startDatabaseByUuidRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startDatabaseByUuid'
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startDatabaseByUuidRequest($uuid, string $contentType = self::contentTypes['startDatabaseByUuid'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling startDatabaseByUuid'
            );
        }


        $resourcePath = '/databases/{uuid}/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stopDatabaseByUuid
     *
     * Stop
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stopDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StopDatabaseByUuid200Response|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2
     */
    public function stopDatabaseByUuid($uuid, string $contentType = self::contentTypes['stopDatabaseByUuid'][0])
    {
        list($response) = $this->stopDatabaseByUuidWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation stopDatabaseByUuidWithHttpInfo
     *
     * Stop
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stopDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StopDatabaseByUuid200Response|\OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject2, HTTP status code, HTTP response headers (array of strings)
     */
    public function stopDatabaseByUuidWithHttpInfo($uuid, string $contentType = self::contentTypes['stopDatabaseByUuid'][0])
    {
        $request = $this->stopDatabaseByUuidRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StopDatabaseByUuid200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject1',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject2',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StopDatabaseByUuid200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StopDatabaseByUuid200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation stopDatabaseByUuidAsync
     *
     * Stop
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stopDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopDatabaseByUuidAsync($uuid, string $contentType = self::contentTypes['stopDatabaseByUuid'][0])
    {
        return $this->stopDatabaseByUuidAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stopDatabaseByUuidAsyncWithHttpInfo
     *
     * Stop
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stopDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopDatabaseByUuidAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['stopDatabaseByUuid'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StopDatabaseByUuid200Response';
        $request = $this->stopDatabaseByUuidRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stopDatabaseByUuid'
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stopDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stopDatabaseByUuidRequest($uuid, string $contentType = self::contentTypes['stopDatabaseByUuid'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling stopDatabaseByUuid'
            );
        }


        $resourcePath = '/databases/{uuid}/stop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDatabaseByUuid
     *
     * Update
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  \OpenAPI\Client\Model\UpdateDatabaseByUuidRequest $update_database_by_uuid_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateDatabaseByUuid($uuid, $update_database_by_uuid_request, string $contentType = self::contentTypes['updateDatabaseByUuid'][0])
    {
        $this->updateDatabaseByUuidWithHttpInfo($uuid, $update_database_by_uuid_request, $contentType);
    }

    /**
     * Operation updateDatabaseByUuidWithHttpInfo
     *
     * Update
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  \OpenAPI\Client\Model\UpdateDatabaseByUuidRequest $update_database_by_uuid_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDatabaseByUuidWithHttpInfo($uuid, $update_database_by_uuid_request, string $contentType = self::contentTypes['updateDatabaseByUuid'][0])
    {
        $request = $this->updateDatabaseByUuidRequest($uuid, $update_database_by_uuid_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateDatabaseByUuidAsync
     *
     * Update
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  \OpenAPI\Client\Model\UpdateDatabaseByUuidRequest $update_database_by_uuid_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDatabaseByUuidAsync($uuid, $update_database_by_uuid_request, string $contentType = self::contentTypes['updateDatabaseByUuid'][0])
    {
        return $this->updateDatabaseByUuidAsyncWithHttpInfo($uuid, $update_database_by_uuid_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDatabaseByUuidAsyncWithHttpInfo
     *
     * Update
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  \OpenAPI\Client\Model\UpdateDatabaseByUuidRequest $update_database_by_uuid_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDatabaseByUuidAsyncWithHttpInfo($uuid, $update_database_by_uuid_request, string $contentType = self::contentTypes['updateDatabaseByUuid'][0])
    {
        $returnType = '';
        $request = $this->updateDatabaseByUuidRequest($uuid, $update_database_by_uuid_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDatabaseByUuid'
     *
     * @param  string $uuid UUID of the database. (required)
     * @param  \OpenAPI\Client\Model\UpdateDatabaseByUuidRequest $update_database_by_uuid_request Database data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDatabaseByUuid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDatabaseByUuidRequest($uuid, $update_database_by_uuid_request, string $contentType = self::contentTypes['updateDatabaseByUuid'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling updateDatabaseByUuid'
            );
        }

        // verify the required parameter 'update_database_by_uuid_request' is set
        if ($update_database_by_uuid_request === null || (is_array($update_database_by_uuid_request) && count($update_database_by_uuid_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_database_by_uuid_request when calling updateDatabaseByUuid'
            );
        }


        $resourcePath = '/databases/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_database_by_uuid_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_database_by_uuid_request));
            } else {
                $httpBody = $update_database_by_uuid_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
